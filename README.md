## Redis介绍
Redis是一个高性能内存键值对数据库，支持的数据结构有字符串，哈希表，数组，集合，有序集合五种数据结构，对应的相关结构为String，Hash，List，Set，SortedSet。

Redis可用于数据缓存，计数器，消息代理，分布式锁；支持主从复制，持久化，事务和lua脚本。

与传统数据库采用磁盘持久化数据相比，Redis使用的是一种内存优化型数据库，读写速度快

## Redis五种数据结构和使用场景

**String（字符串）：**

在Redis中， 字符串可被修改，采用的为简单动态字符串SDS，结构更像列表，维护字节数并在其中分配空间，减少频繁内存分配

1. 当字符串长度小于1M时，扩容空间翻倍
2. 当字符串长度大于1M时，扩容每次增加1M
3. 为保证空间不会浪费，最长字符串为512M

字符串类型的结构常用来存储key-value键值对

** List（数组）：**

在底层是一个连续的内存，当数据量较小时，数据时相邻存储，分配的是一个连续的内存空间。当数据量大时，将其转换为快速列表结构

如果使用简单链表，存储每个元素的位置将额外维护一个前指针和后指针，加大了内存开销，造成大量的内存碎片。所以在3.2后，采用zipList+链表的混合结构

应用场景：
1. 朋友圈内容发布
2. 使用lpush,rpop或lpop,rpush实现消息队列

 ** Hash（哈希）：**

 底层为数组+链表模式，Redis中Hash存储的值可能是字符串信息。
 
 Hash与String都可以用来存储用户信息，不过Hash可存储用户的每个字段信息，而字符串在修改是需要将用户信息查询出来后解析为用户信息，修改完成后再序列化为字符串保存到Redis中。相比而言，Hash可减少网络流量，但是占用空间更大。

 应用场景：
 1. 购物车商品保存，实现用户id，商品id，数量信息的保存

**Set（集合）：**

内部键值对是无序、唯一的，内部结构的实现相当于是特殊字典，所有的value都是，当集合中最后一个元素被移除后，数据结构自动删除，内存回收

应用场景：
1. 粉丝，共同好友

** SortedSet（有序集合）**

保证了内部值的唯一性，为每个值进行了打分，表示该值的排序权重，内部实现使用一种“跳转列表”的数据结构

使用场景：
1. 用于排序，实现动态排序，
2. 存储学生成绩，value为学生id，score为考试成绩，按照分数打分

 
## Redis的内存淘汰策略

Redis对设置了过期时间的数据保存到单独的字典表中，定期删除字典表中过期的数据

但是在删除过期数据时，并不是全部删除，而是采用贪婪策略
1. 在字典表中随机抽取20个建
2. 删除其中20个密钥
3. 如果删除的数据量超过了1/4，再次抽取数据进行还是拿出

惰性删除：

在用户访问数据时，判断当前数据是否过期，过期直接删除不返回

对于一些定时删除的数据未能正常删除时，采用与惰性删除相结合，即使过期，也能手动检查


## 数据一致性

这里的数据一致性指MySQL中与Redis中数据是否一致，数据一致为MySQL中数据=Redis中数据；数据不一致则为MySQL中数据≠Redis中数据

解决数据不一致情况
1. 根据是否接收写请求，可以把缓存分成读写缓存和只读缓存。
2. 只读缓存：只在缓存进行数据查找，即使用 “更新数据库+删除缓存” 策略；
3. 读写缓存：需要在缓存中对数据进行增删改查，即使用 “更新数据库+更新缓存”策略。
